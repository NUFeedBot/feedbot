#!/bin/python3

import os
from openai import OpenAI
import json
import argparse
import requests
from assignmentdata import AssignmentStatement, InvalidSubmission
from slicesubmission import slice_submission
import pprint


DEFAULT_PROMPTS = {
    'general':'Give feedback on the following code written in the Beginning'
        + ' Student Language Dialect of Racket in terms of its'
        + ' adherence to the Design Recipe from the textbook How to Design Programs.\n',
    'statement':'The problem statement given to the student was:\n',
    'code':'The student\'s code for this problem was:\n\n',


    'data_design': 'Give feedback on the following code written in the Beginning'
        + ' Student Language Dialect of Racket in terms of its'
        + ' adherence to the Data Design Recipe from the textbook How to Design Programs:\n\n',
    'implementation': 'Give feedback on the following code written in the Beginning'
        + ' Student Language Dialect of Racket in terms of how well it follows'
        + ' the Design Recipe from the textbook How to Design Programs:\n\n',
    'list_abstraction': 'Give feedback on these Racket list abstractions:\n\n',
}


# Gets a response from OpenAI, given the OpenAI client, a prompt, and code
# (OpenAI, dict, int, Submission) -> str
def get_comment(client, config, problem_no, sub):
    prompt = get_problem_prompt(config, problem_no)
    text = get_problem_text(sub, problem_no)

    chat_completion = client.chat.completions.create(
        messages=[
            {
                "role": "user",
                "content": prompt + text,
            }
        ],
        model="gpt-4",
    )

    print(prompt + text)

    return chat_completion.choices[0].message.content


# Sends a POST request to the given URL, using the given list of comments
# (str (URL), List[Comment]) -> Response
def send_request(url, code, comments):
    addendum = 'entry'

    request_obj = {
        'code': code,
        'comments': json.dumps(
            {
                "comments": comments
            }
        ),
    }

    return requests.post(url + "/" + addendum, params=request_obj)


# Gets the text of the given problem from the code
# (Submission, int) -> str
def get_problem_text(code, problem_no):
    return code.get_problem(problem_no)


# Gets the prompt for the given problem_no in the config
# (dict, int) -> str
def get_problem_prompt(config, problem_no):
    return DEFAULT_PROMPTS['general'] + DEFAULT_PROMPTS['statement'] + config['assignment'].problems[problem_no].statement + '\n\n' + DEFAULT_PROMPTS['code']


# Returns a correct configuration or prints error msg and quits
# dict -> dict
def normalize_config(config):
    ret = config.copy()
    ret.setdefault('prompts', DEFAULT_PROMPTS)
    ret.setdefault('assignment', {})
    ret['assignment'] = AssignmentStatement(ret['assignment'])
    return ret


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog='FeedBot autograder'
    )

    parser.add_argument('-l', '--local', action='store_true')
    parser.add_argument(
        '-u',
        '--url',
        default='https://feedbot-website-lively-firefly-3841.fly.dev/'
    )

    args = parser.parse_args()

    if args.local:
        with open('config.json', 'r') as conf:
            config = json.loads(conf.read())
    else:
        with open('source/config.json', 'r') as conf:
            config = json.loads(conf.read())

    config = normalize_config(config)

    if args.local:
        subdata = slice_submission('test_src.rkt')
    else:
        subdata = slice_submission('submission/src.rkt')
    if not subdata.has_all_problems(range(len(config['assignment'].problems))):
        raise InvalidSubmission("Submission does not have all problems", -1)

    if args.local:
        with open('key', 'r') as key:
            client = OpenAI(
                api_key=key.read().rstrip()
            )
    else:
        with open('source/key', 'r') as key:
            client = OpenAI(
                api_key=key.read().rstrip()
            )
    
    answer = get_comment(
        client,
        config,
        0, # Currently hardcoded problem number
        subdata
    )

    x = send_request(
        args.url,
        subdata.full_code,
        [
            {
                "line_number": 0,
                "text": answer
            }
        ]
    )

    output = {
        "score": 50.0,
        "tests": [
            {
                "output": x.text,
                # "answer": answer # <-- use this to get output without needing to have the server set up 
            },
        ],
    }

    

    if args.local:
        result_path = os.open('.', os.O_RDONLY)
        
        # The above was causing an error for me so I used this instead
        # with open('results.json', 'w') as f:
        #     json.dump(output, f)
    else:
        result_path = os.open('results', os.O_RDONLY)

    def opener(path, flags):
        return os.open(path, flags, dir_fd=result_path)

    with open('results.json', 'w', opener=opener) as f:
        print(json.dumps(output), file=f)

    os.close(result_path)
